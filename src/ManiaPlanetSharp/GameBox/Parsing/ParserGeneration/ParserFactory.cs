using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;

namespace ManiaPlanetSharp.GameBox.Parsing.ParserGeneration
{
    public static class ParserFactory
    {
        static ParserFactory()
        {
            ParserFactory.InitializePrecompiledParsers();
        }

        private static bool initialized = false;
        public static void InitializePrecompiledParsers()
        {
            if (!initialized)
            {
                Console.WriteLine("Initializing Parser Factory...");
                var assemblies = AppDomain.CurrentDomain.GetAssemblies().Where(p => !p.IsDynamic);
                var chunkParserClass = assemblies.Select(a => a.DefinedTypes.FirstOrDefault(t => t.FullName == "ManiaPlanetSharp.GameBox.Parsing.ParserGeneration.AutoGenerated.AutoGeneratedParsers")).FirstOrDefault(t => t != null);
                if (chunkParserClass == null)
                {
                    try
                    {
                        var parserAssembly = Assembly.Load("ManiaPlanetSharp.GameBox.AutoGenerated");
                        chunkParserClass = parserAssembly.DefinedTypes.FirstOrDefault(t => t.FullName == "ManiaPlanetSharp.GameBox.Parsing.ParserGeneration.AutoGenerated.AutoGeneratedParsers");
                    }
                    catch
                    { }
                    if (chunkParserClass == null)
                    {
                        Console.WriteLine("No pre-generated parsers located.");
                    }
                }
                if (chunkParserClass != null)
                {
                    Console.WriteLine("Located pre-generated parsers.");
                    try
                    {
                        foreach (var parser in (Dictionary<Type, IParser<Chunk>>)chunkParserClass.GetProperty("ChunkParsers", BindingFlags.Public | BindingFlags.Static).GetValue(null))
                        {
                            Console.WriteLine("    Found chunk parser for type " + parser.Key.ToString());
                            ParserFactory.chunkParsers.TryAdd(parser.Key, parser.Value);
                        }
                        foreach (var parser in (Dictionary<Type, IParser<object>>)chunkParserClass.GetProperty("StructParsers", BindingFlags.Public | BindingFlags.Static).GetValue(null))
                        {
                            Console.WriteLine("    Found struct parser for type " + parser.Key.ToString());
                            ParserFactory.structParsers.TryAdd(parser.Key, parser.Value);
                        }
                    }
                    catch
                    {

                    }
                }
            }
            initialized = true;
        }

        private static ConcurrentDictionary<Type, IParser<Chunk>> chunkParsers = new ConcurrentDictionary<Type, IParser<Chunk>>();
        public static ChunkParser<TChunk> GetChunkParser<TChunk>()
            where TChunk : Chunk, new()
        {
            return (ChunkParser<TChunk>)chunkParsers.GetOrAdd(typeof(TChunk), _ => ChunkParser<TChunk>.GenerateParser());
        }

        private static ConcurrentDictionary<Type, IParser<object>> structParsers = new ConcurrentDictionary<Type, IParser<object>>();
        public static CustomStructParser<TStruct> GetCustomStructParser<TStruct>()
            where TStruct : new()
        {
            return (CustomStructParser<TStruct>)structParsers.GetOrAdd(typeof(TStruct), _ => (IParser<object>)CustomStructParser<TStruct>.GenerateParser());
        }
    }
}
