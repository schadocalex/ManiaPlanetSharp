using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;

namespace ManiaPlanetSharp.GameBox.Parsing
{
    /// <summary>
    /// Central factory that provides parsers for chunks and custom structs, either precompiled or dynamically generated.
    /// </summary>
    public static class ParserFactory
    {
        /// <summary>
        /// Static initialisation of the <c>ParserFactory</c> class.
        /// </summary>
        static ParserFactory()
        {
            ParserFactory.InitializePrecompiledParsers();
        }

        private static bool initialized = false;
        /// <summary>
        /// Tries to load the <c>ManiaPlanetSharp.GameBox.AutoGenerated</c> assembly containing the precompiled parsers. This method is run automatically at the first call to the <c>ParserFactory</c>.
        /// </summary>
        public static void InitializePrecompiledParsers()
        {
            if (!initialized && GlobalParserSettings.UsePrecompiledParsersIfPresent)
            {
                Debug.WriteLine("Initializing Parser Factory...");
                var assemblies = AppDomain.CurrentDomain.GetAssemblies().Where(p => !p.IsDynamic).Where(p => p.FullName.Contains("ManiaPlanetSharp.GameBox.AutoGenerated")).ToArray();
                var chunkParserClass = assemblies.Select(a => a.DefinedTypes.FirstOrDefault(t => t.FullName == "ManiaPlanetSharp.GameBox.Parsing.ParserGeneration.AutoGenerated.AutoGeneratedParsers")).FirstOrDefault(t => t != null);
                if (chunkParserClass == null)
                {
                    try
                    {
                        var parserAssembly = Assembly.Load("ManiaPlanetSharp.GameBox.AutoGenerated");
                        chunkParserClass = parserAssembly.DefinedTypes.FirstOrDefault(t => t.FullName == "ManiaPlanetSharp.GameBox.Parsing.ParserGeneration.AutoGenerated.AutoGeneratedParsers");
                    }
                    catch
                    { }
                    if (chunkParserClass == null)
                    {
                        Debug.WriteLine("No pre-generated parsers located.");
                    }
                }
                if (chunkParserClass != null)
                {
                    Debug.WriteLine("Located pre-generated parsers.");
                    try
                    {
                        foreach (var parser in (Dictionary<Type, IChunkParser<Chunk>>)chunkParserClass.GetProperty("ChunkParsers", BindingFlags.Public | BindingFlags.Static).GetValue(null))
                        {
                            Debug.WriteLine("    Found chunk parser for type " + parser.Key.ToString());
                            if (ParserFactory.chunkParsers.TryAdd(parser.Key, parser.Value))
                            {
                                foreach (uint chunkId in parser.Value.ParseableIds)
                                {
                                    chunkParsersByID.Add(chunkId, parser.Value);
                                }
                            }
                        }
                        foreach (var parser in (Dictionary<Type, IParser<object>>)chunkParserClass.GetProperty("StructParsers", BindingFlags.Public | BindingFlags.Static).GetValue(null))
                        {
                            Debug.WriteLine("    Found struct parser for type " + parser.Key.ToString());
                            ParserFactory.structParsers.TryAdd(parser.Key, parser.Value);
                        }
                    }
                    catch (Exception ex)
                    {
                        throw ex;
                    }
                }
            }
            initialized = true;
        }

        /// <summary>
        /// Clears the cached parsers.
        /// </summary>
        internal static void ClearParsers()
        {
            chunkParsers.Clear();
            chunkParsersByID.Clear();
        }

        private static ConcurrentDictionary<Type, IChunkParser<Chunk>> chunkParsers = new ConcurrentDictionary<Type, IChunkParser<Chunk>>();
        private static Dictionary<uint, IChunkParser<Chunk>> chunkParsersByID = new Dictionary<uint, IChunkParser<Chunk>>();

        /// <summary>
        /// Returns a parser for the specified chunk type either from the precompiled parsers or the cache of previously dynamically generated parsers or generates one dynamically.
        /// </summary>
        /// <typeparam name="TChunk">The type of chunk to be parsed</typeparam>
        /// <returns></returns>
        public static ChunkParser<TChunk> GetChunkParser<TChunk>()
            where TChunk : Chunk, new()
        {
            return (ChunkParser<TChunk>)chunkParsers.GetOrAdd(typeof(TChunk), _ =>
            {
                Debug.WriteLine($"Generating parser for type {typeof(TChunk).Name}.");
                var parser = ChunkParser<TChunk>.GenerateParser();
                foreach (uint chunkId in parser.ParseableIds)
                {
                    chunkParsersByID.Add(chunkId, parser);
                }
                return parser;
            });
        }

        /// <summary>
        /// Returns a parser for the specified chunk type either from the precompiled parsers or the cache of previously dynamically generated parsers or generates one dynamically.
        /// </summary>
        /// <param name="chunkId">The chunk id to be parsed.</param>
        /// <returns></returns>
        public static IChunkParser<Chunk> GetChunkParser(uint chunkId)
        {
            return chunkParsersByID[chunkId];
        }

        /// <summary>
        /// Returns a parser for the specified chunk type either from the precompiled parsers or the cache of previously dynamically generated parsers or generates one dynamically.
        /// </summary>
        /// <param name="chunkId">The chunk id to be parsed.</param>
        /// <param name="parser">The chunk parser.</param>
        /// <returns><c>true</c>, if a parser could be found or generated; <c>false</c> if no parser is available.</returns>
        public static bool TryGetChunkParser(uint chunkId, out IChunkParser<Chunk> parser)
        {
            if (chunkParsersByID.TryGetValue(chunkId, out parser))
            {
                return true;
            }
            else
            {
                Type chunkType = AppDomain.CurrentDomain.GetAssemblies()
                    .Where(p => !p.IsDynamic)
                    .SelectMany(a => a.DefinedTypes)
                    .Where(t => typeof(Chunk).IsAssignableFrom(t.AsType()))
                    .SelectMany(t => t.GetCustomAttributes<ChunkAttribute>().Select(a => Tuple.Create(t, a.Id)))
                    .FirstOrDefault(t => t.Item2 == chunkId)
                    .Item1?.AsType();
                if (chunkType != null)
                {
                    parser = (IChunkParser<Chunk>)typeof(ChunkParser<>).MakeGenericType(chunkType).GetMethod("GenerateParser", BindingFlags.Public | BindingFlags.Static).Invoke(null, null);
                    return true;
                }
            }
            parser = null;
            return false;
        }

        internal static IEnumerable<uint> GetParseableIds()
        {
            return chunkParsersByID.Keys;
        }



        private static ConcurrentDictionary<Type, IParser<object>> structParsers = new ConcurrentDictionary<Type, IParser<object>>();

        public static CustomStructParser<TStruct> GetCustomStructParser<TStruct>()
            where TStruct : new()
        {
            return (CustomStructParser<TStruct>)structParsers.GetOrAdd(typeof(TStruct), _ =>
            {
                Debug.WriteLine($"Generating parser for type {typeof(TStruct).Name}.");
                return (IParser<object>)CustomStructParser<TStruct>.GenerateParser();
            });
        }
    }
}
